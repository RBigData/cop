% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cop_allreduce.r
\name{cop_allreduce}
\alias{cop_allreduce}
\alias{cop_reduce}
\title{Custom Reduction}
\usage{
cop_allreduce(x, op, commutative = FALSE, comm = 0L)

cop_reduce(x, op, root, commutative = FALSE, comm = 0L)
}
\arguments{
\item{x}{The input data. Should be a numeric matrix. The matrix should be the same
dimensions across all processes.}

\item{op}{A binary operation for numeric matrices. The function should be associative,
and inputs/outputs are assumed to have the same dimensions. See the Details
section for more information.}

\item{commutative}{Is the operation commutative? Should be one of \code{TRUE} or \code{FALSE}.}

\item{comm}{MPI communicator number.}

\item{root}{MPI rank that should receive the return in the non-all version.}
}
\value{
If the all version is called or if the calling rank is equal to \code{root},
then a numeric matrix is returned, and otherwise \code{NULL}.
}
\description{
This performs a reduce/allreduce operation on a matrix with a custom binary
operation. Currently, only normal dense/numeric matrices are supported.
}
\details{
This is a generalization of the \code{qr_allreduce()}/\code{qr_reduce()}
methods also offered by this package. Conceptually, \code{qr_reduce()} is the
same as doing \code{cop_reduce()} with
\code{op = function(a, b) qr.R(qr(a, b))} and \code{commutative=TRUE},
although the internals of \code{qr_reduce()} are actually quite different.
In general, it should be faster and use  less memory.


The function should take inputs of the same dimension, and the output should
be of the same dimension as the inputs. Indeed, for intermediary
calculations, the output of the op at one level will be an input for the next
evaliation. This criterion is assumed and not validated or tested.
Violating it could cause crashes or difficult to understand memory errors.

The operation should be associative, meaning that you should be able to put
parentheses wherever you want with 2 or more chained calls. Said another
way, \code{a op b op c} is the same whether evaluated \code{a op (b op c)} or
\code{(a op b) op c}. The operation does not have to be commutative, which
would require that \code{a op b} is the same as \code{b op a}. However, if it
is, then there may be an improvement to performance by correctly specifying
it as such via the \code{commutative} argument.
}
\examples{
\dontrun{
suppressMessages(library(cop))

x = matrix(1:4, 2) + 10*comm.rank()
add = function(a, b) a+b
out = cop_allreduce(x, fun=add, commutative=TRUE)
mpi_print(out)

finalize()
}

}
\seealso{
\code{\link{qr_allreduce}()}
}
