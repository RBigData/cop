% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qr_allreduce.r
\name{qr_allreduce}
\alias{qr_allreduce}
\alias{qr_reduce}
\title{QR Reduction}
\usage{
qr_allreduce(x, comm = 0L, type = "double")

qr_reduce(x, root = 0L, comm = 0L, type = "double")
}
\arguments{
\item{x}{The input data. Should be a numeric matrix. The matrix should be the same
dimensions across all processes.}

\item{comm}{MPI communicator number.}

\item{type}{The precision used for the intermediate calculations. Should be one of
"double" or "float".}

\item{root}{MPI rank that should receive the return in the non-all version.}
}
\value{
If the all version is called or if the calling rank is equal to \code{root},
then a numeric matrix is returned, and otherwise \code{NULL}.
}
\description{
Given an R matrix from a QR factorization on each process, this computes the
R matrix which is conceptually calculated by "stacking" all R matrices on top
of each other (like \code{do.call(rbind, R_list)}). The way this is actually
calculated is much more memory efficient, and probably more run time
efficient as well, if the local R matrices aren't very small.
}
\details{
This can be used to create a TSQR. If the tall matrix is split by rows across
processes, compute the R matrix on the local chunk and then hand it to
\code{qr_reduce()}.


This works by defining a custom MPI data type (dense matrix) with a custom
reduction operation (given 2 R matrices, "stack" them, compute the stacked
QR and emit R). Each local operation uses the LAPACK functions
\code{_geqp3()}, similar to R's \code{qr()} with \code{LAPACK=TRUE}.
}
\examples{
\dontrun{
suppressMessages(library(cop))

x = matrix(1:4, 2) + 10*comm.rank()
out = qr_reduce(x)
mpi_print(out)

finalize()
}

}
\seealso{
\code{\link{cop_allreduce}()}
}
